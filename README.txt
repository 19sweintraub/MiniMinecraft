~Chris Kao:  ~

I was responsible for creating the procedural sky. I based my code off of Professor Mally’s provided code. First, I referenced some sunset drone panoramas I’ve taken (e.g. www.phillybydrone.com/panoramas/1213-walnut) and used 5 colors from each panorama as inspiration for the new color schemes. That was the easy part. Then, I animated the sun across the sky from east to west, and coded it such that a 24 hour day cycle is around 2 minutes machine time. Animating the sun is not enough, as I also had to update the light source direction in the Lambert shader. Our team ran into a large problem when merging the procedural sky code with the post processing code, because Sam and I used different draw() functions. After many hours of debugging, we realized that we needed to use the same draw() function. And we also needed to set the quad.cpp position to 0.999999 instead of 0.99. It was counterintuitive to us that such a small difference in numbers would make a huge impact.

For Milestone 2: I implemented the L-system river generation. First, I modified the HW 3 rasterizer in order to draw the linear and delta rivers in black and white in 2D using QImage. I went to ask for help during office hours, and Connie gave me some tips for the alphabet / grammar structure. In order to  draw the delta river, I needed to include a probability function that with 95% probability would keep the river drawing straight, and with 5% probability would branch. I defined a new grammar alphabet letter called Y to represent a river that branched. Once I felt comfortable that my L-system turtle was working, I copied and pasted my files into my branch of the Milestone 2. I spent a lot of time implementing the terrain carving. Initially the naive approach was to generate a river with width 5 that would carve to the left and right. However, I noticed that as the river started bending, it was not trivial to know what was “left” and “right”, especially when the river orientation was around 45 degrees. In the end, I decided to generate the rivers starting at the center of the terrain, with one going up and one going down. The river going up is a linear river with a width of 5. The river going down is a delta river with a width of 3. Its width is smaller because the delta river spreads out more over space. One challenge our team ran into while generating rivers is that when we encountered negative z values, the fbm function and the chunking system created repeated terrains that were wrong. As a fix, we set the origin at a large positive value of x = 3200, z = 3200. After that, the terrain generated correctly with no problem. Another challenge we ran into is that multithreading workers that generated terrain did not generate an entire row of chunks when going in the positive z direction or negative z direction. But it did generate an entire column of chunks when going in the negative x direction or positive x direction.

For Milestone 1: For FBM I used the provided noise functions from the procedural slides. I divided the input x and z values by a constant and played with the number until the terrain looked like something that was walkable, meaning that it is flatter. For creating/deleting a block, I increased the distance to 10 units so that it would be easier to place blocks in the world and also fore debugging purposes. The main challenge there was figuring out to apply a 0.5 offset because of the way the blocks are indexed.

~Sam Weintraub: ~

For milestone 3, I implemented Distance fog, post-process camera overlay, and a basic fluid simulation. To implement distance fog, I passed in the z-coordinate of the projected geometry into the fragment shader and added white light that was proportional to the distance. I clamped the maximum white light that would be added so that the geometry could still be realized at a distance.

To implement the post-process camera overlay, I modeled the mygl pipeline based on homework 4/5. The primary change here was to make sure that the shaders output vec4s to enable transparency. There were many challenges in the details here. Namely including the layout(location = 0) at the top of the fragment shader and changing the glsl compiler version to support this. Also, there were a lot of challenges with postprocessshader.cpp inheriting from the shader program. I had to make sure that each class set-up unique member variables and had their own relevant draw functions. Once this was implemented I built an underwater overlay. The overlay uses a guassian blur and a sine function to to distort the players view. It also adds blue (obviously) and uses worley noise to modify the amplitude of the sine function distortion.

Finally, I spent some time working on fluid simulation. I made it so that if you remove a block, water will expand to fill empty space for 7 blocks. To do this, I implemented a breadth first search algorithm. If a block that is adjacent to water is removed, the breadth first search begins. The algorithm searches the grid radially in search for connected empty blocks and fills them with water. The algorithm is contrained to look only at blocks at the same plane (x and z) or below (-y) because water cannot flow upward.

One issue that persists is the with strange opaque planes rendering inside of the rivers that can only be seen at certain angles. To fix this, I believe I would need to draw all opaque blocks then all transparent blocks rather than drawing a chunks opaque blocks then a chunks transparent blocks then moving to the next chunk. This would require changing the gldrawscene function to have 2 draw passes and having specific draw functions within the shaderprogram class that draws opaque vs transparent vbos for a given chunk.

For milestone 2 I focused on implementing texturing and texture animation. I went with the qrc file approach in order to locate the texture image for sampling. This required modifying the .pro file within qt creator. Once the texture image was accessible, I hardcoded the bottom left corner of the texture sample that corresponds to a given blocks texture. For some textures this involved looking at the normal to determine if the texture is unique to the top or sides of the block. Additionally I expanded the interleaved VBO to support cosine power, animation flag, and UV coordinates. If an animation flag is present, the shader samples the surrounding block linearly as a function of time to simulate moving water and lava. Finally, to implement transparent blocks, I built in support for a second interleaved VBO and corresponding bind / buffer functions. Now, whenever draw is called, the opaque VBO is drawn and then the transparent VBO is drawn ensuring proper rendering. 

For milestone 1: To implement efficient chunking VBO creation, I implemented an algorithm that looks at each non empty cube and only adds a face to the VBO if an empty cube is adjacent. The most challenging part of this algorithm was checking for faces between chunks. In order to do this, I put the QHash that contained the global chunk information on the heap and made each chunk have a member variable pointing to this global hash map. Lastly, I used a 64 bit integer to make a key out of an X and Z position tuple for the hash map and added logic to the get and setblock functions such that new chunks were created if a block was to be placed in a chunk that did not exist yet.

~Omkar Savant: ~

For Milestone 3, I created NPC objects that are scattered through the world and can interact with the terrain and player. By default, the NPCs just look like stationary blocks in the world with a pumpkin texture, which was sampled from the texture file. However, I created a mode called "Pumpkin Pursuit," where the player is chased by all of the pumpkins around the terrain if they press the letter "p". If you do not want to be chased anymore, pressing "p" again turns this off. The pumpkins' goal is to reach your location, so they cooperate and climb on top of each other if you are in flying mode in order to reach you. I implemented these NPCs as block objects in the world since they naturally interact with the environment and fit well into the chunking pipeline that we already had. In order to make them interact with the terrain, I subjected the NPC objects to "gravity" by ensuring that they were always on top of a non-empty block. Each NPC is added to the vector of NPCs in mygl.cpp.
 
In order to move around the world, I used a timer object to call a position update function periodically. Their position update function involves finding the vector between the NPC's current location and the player's location and dividing that by the magnitude of the vector to get the step at each time step. Then, the NPC's position is updated by this step vector. The gravity function ensures that in the process, they don't lift off the ground and fly to the player. One interesting problem I encountered was that the NPCs could only travel in the negative direction and not the positive world direction. This was because to figure out where to invoke setBlockAt for their new position, I was casting their new calculated position to an int. However, because (int) essentially floors the number, any step that was less than one meant that the pumpkin would not move at all. For negative numbers, a step of even 0.01 can result in the flooring operation returning a new int, and new position in the process. 

I also added sounds. When the NPCs are near you and you're in pursuit mode, you will hear a fun creepy sound. There are also sounds for swimming, wind sounds when flying, and running sounds when you are moving on the ground. I did this by adding the sound files as a resource and adding multimedia to the .pro file. In order to get the sounds to work at a specific time, I am running a sound update loop in the myGL timer update, and this checks the state of various objects like the distance of the pumpkins and the state of the player to determine which sound to play. Please run QMake to allow the sounds to work. 

For Milestone 2, I continued to work on the game engine by creating swimming and lava walking modes for the player, and also did multithreading for terrain generation. To create swimming and walking in lava effects, I slow down the player anytime they are below a layer of water or lava. This is determined by raycasting above the player for 6 blocks and seeing if there are any relevant blocks in the way. If this is the case, the player's velocity is decreased to 2/3 of its usual, and gravity no longer applies. Essentially the player is flying in the water, but there are still collisions with obstacles. To show the overlay, I created a drawable object that fills up the whole screen and is placed just behind the front clip plane. It is colored based on the player's state. To enable multithreading, I used the QRunnable class. I created a separate class called worker, which contains one thread per instance. The run() function is overriden to implement the createScene() function of the terrain class, as well as render the linear and delta rivers. This allows very fast generation of the terrain and the player moves near the boundaries. I did not need to create a list of chunks to be added to the chunk map for the purpose of this multithreading exercise because of the way we implement chunk creation. We already had a chunk map, and only draw chunks if a boolean called hasChanged() is true for the chunk. This is true if a block has been added or deleted in the chunk or if the chunk is a new chunk created at scene expansion. 

For Milestone 1, I created a player class which uses the same camera as the one from myGL.cpp to serve as its worldview. To implement collision detection, I created points at 12 different points on the "body" of the player and at every update, I checked whether there was a block at that point using the getBlockAt() function whenever the player was commanded to translate along its look, forward, or up vectors. If there was a collision, the movement was reverted to a previous state. Whenever there were less than 3 of the player's feet on the ground, I set the velocity to decrement at a steady rate. This simulated gravity. In order to jump, the player's upward velocity is set to be 2X of the player's gravity. When the player is flying, gravity and collision checks do not affect the player's movement. One challenge I had was figuring out how to reliably check for collisions and allow the player to keep moving instead of being paralyzed in one spot given that the feet often detect collisions. 
